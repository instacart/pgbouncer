This document describes the packet format and structure used to dump
packets of any lenght from pgbouncer to go-replayer.

```
Generic packet       Header packet        Fragment packet
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│    client_id     │ │    client_id     │ │    client_id     │        Arbitrary client identifier
│     4 bytes      │ │     4 bytes      │ │     4 bytes      │        generated by pgbouncer for each new client, used for tx control state
├──────────────────┤ ├──────────────────┤ ├──────────────────┤
│    packet_id     │ │    packet_id     │ │    packet_id     │        Arbitrary packet identifier
│     4 bytes      │ │     4 bytes      │ │     4 bytes      │        generated by pgbouncer for each new packet on the same client
├──────────────────┤ ├──────────────────┤ ├──────────────────┤        used to make fragments sticky to header on reconstruction
│  query_interval  │ │  query_interval  │ │  query_interval  │        
│     4 bytes      │ │     4 bytes      │ │     4 bytes      │        Interval from last query in microseconds
├──────────────────┤ ├──────────────────┤ ├──────────────────┤
│     buf_len      │ │     buf_len      │ │     buf_len      │        How much data this single packet carries
│     4 bytes      │ │     4 bytes      │ │     4 bytes      │        the value depends on packet type (header or fragment)
├──────────────────┤ ├──────────────────┤ ├──────────────────┤        See example below
│┼────────────────┼│ │┼────────────────┼│ │┼────────────────┼│
││    pkt_type    ││ ││    pkt_type    ││ ││    pkt_type    ││        Follows Postgres Message protocol
││    1 byte      ││ ││    1 byte      ││ ││    1 byte      ││        Custom packets: ! for client connection/disconnection
│┼────────────────┼│ │┼────────────────┼│ │┼────────────────┼│                        > for skipped packets
│┼────────────────┼│ │┼────────────────┼│ │┼────────────────┼│                       \0 pgbouncer admin command (used for RELOAD)
││                ││ ││    pkt_len     ││ ││                ││        Special case:   * fragment packet
││    postgres    ││ ││    4 bytes     ││ ││                ││
││    message     ││ │┼────────────────┼│ ││    pkt_data    ││        For header, pkt_len is the total expected size that may
││    payload     ││ ││    pkt_data    ││ ││   {buf_len}    ││        arrive as multiple fragments
││                ││ ││ {buf_len-4-1}  ││ ││                ││
│┼────────────────┼│ │┼────────────────┼│ │┼────────────────┼│
└──────────────────┘ └──────────────────┘ └──────────────────┘


 Example 1:  header, complete, type Q, query .select 1;.
 * since the packet is complete, {buf_len == pkt_len)

┌───────────┬───────────┬───────────┬───────────┬────────┬───────────┬──────────────────────────┐
│client_id  │packet_id  │qry_intervl│buf_len    │pkt_type│pkt_len    │pkt_data                  │
├───────────┼───────────┼───────────┼───────────┼────────┼───────────┼──────────────────────────┤
│00 00 12 34│00 00 ab cd│00 00 01 00│00 00 00 0e│   51   │00 00 00 0e│73 65 6c 65 63 74 20 31 3b│
└───────────┴───────────┴───────────┴───────────┼────────┼───────────┼──────────────────────────┤
                                              14│   Q    │         14│ s  e  l  e  c  t     1  ;│
                                                ├────────┴───────────┼──────────────────────────┤
                                                │                    │     {buf_len-4-1}        │
                                                ├────────────────────┴──────────────────────────┤
                                                │                  {buf_len}                    │
                                                └───────────────────────────────────────────────┘


 Example 2:  header, incomplete, type Q, query .select .0123456789abcdef.... (len=16kb, pkt_buf=4k)
 * packet is {16kb+5} and dont fit in pkt_buf {4kb}
 * so we check how much we have read from the client socket and populate this in {buf_len}
 * {buf_len} is always <= {pkt_buf}

┌───────────┬───────────┬───────────┬───────────┬────────┬───────────┬───────────────────────────────────────────┐
│client_id  │packet_id  │qry_intervl│buf_len    │pkt_type│pkt_len    │pkt_data                                   │
├───────────┼───────────┼───────────┼───────────┼────────┼───────────┼───────────────────────────────────┬───────┤
│00 00 12 34│00 00 ab cd│00 00 01 00│00 00 10 00│   51   │00 00 40 05│73 65 6c 65 63 74 20 27 30 31 32 33│  ...  │
└───────────┴───────────┴───────────┼───────────┼────────┼───────────┼───────────────────────────────────┼───────┤
                                    │       4096│   Q    │   (16kb+5)│ s  e  l  e  c  t     .  0  1  2  3│ 4079b │
                                    └───────────┼────────┴───────────┼───────────────────────────────────┴───────┤
                                                │                    │      {buf_len-4-1}  4091 bytes            │
                                                ├────────────────────┴───────────────────────────────────────────┤
                                                │                         {buf_len}  4096 bytes                  │
                                                └────────────────────────────────────────────────────────────────┘


 Example 3:  fragment, continuation from packet on example 2
 * {buf_len} is always <= {pkt_buf}
 * fragments does not know about its header or other parts,
   it just carries on the same client_id and packet_id

┌───────────┬───────────┬───────────┬───────────┬────────┬─────────┐
│client_id  │packet_id  │qry_intervl│buf_len    │pkt_type│pkt_data │
├───────────┼───────────┼───────────┼───────────┼────────┼─────────┤
│00 00 12 34│00 00 ab cd│00 00 00 00│00 00 10 00│   2a   │  ...    │
├───────────┴───────────┼───────────┼───────────┼────────┼─────────┤
│  should be the same   │  ignored  │       4096│   *    │{buf_len}│
│     as the header     │           │           │        │         │
└───────────────────────┴───────────┴───────────┴────────┴─────────┘
```
